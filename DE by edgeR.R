# Load data for DE
raw_counts=read.csv("all raw counts.csv", stringsAsFactors=FALSE)

#Download edger for R version 3.6.1
if (!requireNamespace("BiocManager", quietly = TRUE))
  +     install.packages("BiocManager")
BiocManager::install("edgeR")

#Load edgeR
library("edgeR")

#set working directory


#Read in data
counts <- raw_counts[ , -1]
rownames(counts)<-raw_counts[ , 1] #gene Ensembl IDs
View(counts)

#convert count matrix to edgeR DGElist Object

group<- c(rep("Control",3), rep("KO",3))
cds<-DGEList(counts, group=group)
names(cds)
#original count data
head(cds$counts)
#contains sample information
head(cds$samples)
# How many genes have 0 counts across all samples
sum( cds$all.zeros )


##Filter out low count reads keep only genes with at least 1 read per million reads in at least 3 samples
#once this is done, can calculate normalisation factors which correct for different compositions of samples
#effective library size = product of actual library size and these factors

countsPerMillion <- cpm(cds, normalized.lib.sizes=TRUE)
summary(countsPerMillion)
#'summary' is a useful function for exploring numeric data; eg. summary(1:100)
countCheck <- countsPerMillion > 1
head(countCheck)
keep <- which(rowSums(countCheck) >= 3)
cds <- cds[keep,]
summary(cpm(cds))

cds <- calcNormFactors( cds )
cds$samples

# effective library sizes
cds$samples$lib.size * cds$samples$norm.factors


##an MD plot can show the performance of the TMM normalization, visualizes the library size-adjusted log-fold change between two
#libraries (the difference) against the average log-expression across those libraries (the mean)
#The following MD plot is generated by comparing sample 1 against an artificial library
#constructed from the average of all other samples.
options(max.print=100000)
plotMD(cpm(cds, log=TRUE), column=1)
abline(h=0, col="red", lty=2, lwd=2)
#Ideally, the bulk of genes should be centred at a log-fold change of zero. This indicates
#that any composition bias between libraries has been successfully removed. This quality
#check should be repeated by constructing a MD plot for each sample. column =1 means smaple 1.


#Multi-Dimensional Scaling (MDS) Plot
#For a few samples, the MDS plot is an appropriate 2D non-linear multidimensional analysis extrapolation. 
plotMDS( cds , main = "MDS Plot", labels = colnames( cds$counts ) )


#Estimating Dispersions
#1st: calculate common dispersion
#each gene gets assigned the same dispersion estimate
#output of the estimation includes estimate and other elements added to object cds
cds <- estimateCommonDisp( cds )
names( cds )
#The estimate
cds$common.dispersion

#2nd calculate Tagwise dispersion
#with common dispersion, can estimate tagwise dispersions
#each gene will get its own dispersion estimate
#Tagwise dispersion
cds <- estimateTagwiseDisp( cds)
names( cds )
summary( cds$tagwise.dispersion)


#Testing
# exactTest() performs pairwise tests for diff exp between 2 groups
# pair indicates which groups should be compared
# output is a list of elements, one of which is a table of results

de.tgw <- exactTest( cds , dispersion="tagwise", pair = c( "Control" , "KO" ) )


# Back to count matrix for tagwise analysis
# Store full topTags results table

resultsTbl.tgw <- topTags( de.tgw , n = nrow( de.tgw$table ) )$table
head( resultsTbl.tgw )

# Names/IDs of DE genes

de.genes.tgw <- rownames( resultsTbl.tgw )[ resultsTbl.tgw$PValue <= 0.05 ]

# Up/Down regulated summary for tagwise results
summary( decideTestsDGE( de.tgw , p.value = 0.05 ) ) # the adjusted p-values are used here


#Output results
#make a table or csv file containing results with concentrations, fold-changes, p-values
#up/down regulated variable, dispersions, and the count matrix

# Change column names to be specific to the analysis, logConc and logFC are the same in both.

colnames( resultsTbl.tgw ) <- c( "logFC" , "logConc" , "pVal.Tgw" , "adj.pVal.Tgw" )
# Below provides the info to re-order the count matrix to be in line with the order of the results.
wh.rows.tgw <- match( rownames( resultsTbl.tgw ) , rownames( cds$counts ) )


# Tagwise Results
combResults.tgw <- cbind( resultsTbl.tgw ,
                          "Tgw.Disp" = cds$tagwise.dispersion[ wh.rows.tgw ] ,
                          "UpDown.Tgw" = decideTestsDGE( de.tgw , p.value = 0.05 )[ wh.rows.tgw ] ,
                          cds$counts[ wh.rows.tgw , ] )
head( combResults.tgw )

# Ouput csv tables of results
write.table( combResults.tgw , file = "combResults_tgw_ex1.csv" , sep = "," , row.names = TRUE )

# Add gene names to results csv
combResults_tgw_ex1 <- read.csv("combResults_tgw_ex1.csv", stringsAsFactors=FALSE)
combResults_tgw_ex1$Gene_ID <- row.names(combResults_tgw_ex1)
gene_ref <- read.csv("gene_ref.csv", stringsAsFactors=FALSE)

final<- merge(combResults_tgw_ex1, gene_ref, by = "Gene_ID")
write.csv(final, file = "Final.csv", row.names = FALSE, quote = FALSE )

# find number of genes above and below cutoff
sum(final$logFC >= 1)
sum(final$logFC <= -1)

#get list of significanlty up regulated
final_up <- final[final$UpDown.Tgw == 1,]
write.csv(final_up, file = "final_up.csv", row.names = FALSE, quote = FALSE )


#get list of significanlty down regulated
final_down <- final[final$UpDown.Tgw == -1,]
write.csv(final_down, file = "final_down.csv", row.names = FALSE, quote = FALSE )


#draw volcano plot:
final=read.table(file.choose(), sep = ",", header = TRUE) 
with(final, plot(logFC, -log10(pVal.Tgw), pch=20, main="Volcano plot", xlim=c(-2.5,2), ylim=c(0,30)))
# Add colored points: red if padj<0.05, FC>2, blue ifpadj<0.05, FC>2
with(subset(final, adj.pVal.Tgw<.05 & logFC>1), points(logFC, -log10(pVal.Tgw), pch=20, col="red"))
with(subset(final, adj.pVal.Tgw<.05 & logFC<(-1)), points(logFC, -log10(pVal.Tgw), pch=20, col="blue"))

